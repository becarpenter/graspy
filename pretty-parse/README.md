# graspy/pretty-parse
## gparseg.py: pretty parser for pcapng traces containing GRASP traffic

Wireshark doesn't support GRASP (or even CBOR) at this time (March 2023).

This parser reads a pcapng capture file, typically generated by Wireshark, and does its best to extract all GRASP packets, and then syntax-checks them. Unless their syntax is badly mangled, it then pretty-prints them. If they are mangled, it prints them as raw Python objects.

Identifying GRASP traffic, apart from multicasts to port 7017 at address ff02::13, isn't simple. The algorithm is roughly as follows:

1. Scan the packet trace once to find all GRASP multicasts. From those UDP packets, extract all IPv6 addresses that can be found. We call these addresses the "players". (That includes parsing M_DISCOVER and M_FLOOD messages.)

2. Scan the packet trace again to find all TCP packets between two players, and identify the ones that are M_RESPONSE messages. Parse them to extract all new IPv6 addresses and add them to the players.

3. Scan the packet trace again to find all TCP packets to/from any of the players, and identify all the ones that are GRASP messages of any kind. (If a TCP payload is valid CBOR and decodes to a list whose first member is a valid GRASP message type integer, the packet will be assumed to be GRASP. If so, but the packet isn't actually GRASP, see the above comment about mangled packets.)

4. Scan the packet trace again to condense the format.

In each of these scans, irrelevant (non-GRASP) packets are discarded.

After all that, a final scan to parse and pretty-print all GRASP packets begins.

The code reuses the main grasp.py definitions and parser. It needs grasp.py and its dependencies in the PYTHON path. It needs cbor2, dpkt and python-pcapng (NOT plain pcapng).

The input (pcapng) file is selected by a Tcl/Tk GUI. The output is printed to standard output.

See grasp.py for license, copyright, and disclaimer.

 
